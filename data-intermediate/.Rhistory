b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "weekly earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
# asec[paidhre == 'No', wage := earnwke / hourslw]
# another option is to use weekly wages
asec[, wage := wkearn / hrs]
asec[is.na(wage) & paidhre == 'Yes', wage := hrearn]
asec$hrly.earn <- log(asec$wage)
asec$wkly.earn <- log(asec$wage * asec$hrs)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(wkly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "weekly earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
# then compare annual earnings
asec[, hrs := hrslw]
asec[, wage := hrearn]
asec[paidhre == 'No', wage := wkearn/hrs]
asec$hrly.earn <- log(asec$wage)
asec$annu.earn <- log(asec$wage * asec$hrs * asec$wkswork)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(annu.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "annual earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
axes = F
# keep lower nonreport rate: hours last week
asec[, hrs := hrslw]
asec[, wage := hrearn]
asec[is.na(hrearn) & paidhre == 'No', wage := wkearn/hrs]
asec$hrly.earn <- log(asec$wage)
asec$wkly.earn <- log(asec$wage * asec$hrs)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(wkly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "weekly earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
# when you use usual hours, 2% less variation is explained by hours, but this is largely because there is less variation to explain
asec[, hrs := uslhrs]
asec[, wage := hrearn]
asec[is.na(hrearn), wage := wkearn/hrs]
asec$hrly.earn <- log(asec$wage)
asec$wkly.earn <- log(asec$wage * asec$hrs)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(wkly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "weekly earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
# asec[paidhre == 'No', wage := earnwke / hourslw]
# another option is to use weekly wages
asec[, wage := wkearn / hrs]
asec[is.na(wage) & paidhre == 'Yes', wage := hrearn]
asec$hrly.earn <- log(asec$wage)
asec$wkly.earn <- log(asec$wage * asec$hrs)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(wkly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "weekly earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
# then compare annual earnings
asec[, hrs := hrslw]
asec[, wage := hrearn]
asec[paidhre == 'No', wage := wkearn/hrs]
asec$hrly.earn <- log(asec$wage)
asec$annu.earn <- log(asec$wage * asec$hrs * asec$wkswork)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(annu.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "annual earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
par(mfrow = c(2,2))
xlim <- c(-.35, .35)
ylim <- c(-.35, .35)
par(mar = c(0,4,2,0))
# keep lower nonreport rate: hours last week
asec[, hrs := hrslw]
asec[, wage := hrearn]
asec[is.na(hrearn) & paidhre == 'No', wage := wkearn/hrs]
asec$hrly.earn <- log(asec$wage)
asec$wkly.earn <- log(asec$wage * asec$hrs)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(wkly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "weekly earnings", ylim = ylim, xlim = xlim, axes = F)
axis(side = 2, labels = T)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
par(mar = c(0,0,2,2))
# when you use usual hours, 2% less variation is explained by hours, but this is largely because there is less variation to explain
asec[, hrs := uslhrs]
asec[, wage := hrearn]
asec[is.na(hrearn), wage := wkearn/hrs]
asec$hrly.earn <- log(asec$wage)
asec$wkly.earn <- log(asec$wage * asec$hrs)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(wkly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "weekly earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
# asec[paidhre == 'No', wage := earnwke / hourslw]
par(mar = c(0,4,0,4))
# another option is to use weekly wages
asec[, wage := wkearn / hrs]
asec[is.na(wage) & paidhre == 'Yes', wage := hrearn]
asec$hrly.earn <- log(asec$wage)
asec$wkly.earn <- log(asec$wage * asec$hrs)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(wkly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "weekly earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
par(mar = c(0,0,2,4))
# then compare annual earnings
asec[, hrs := hrslw]
asec[, wage := hrearn]
asec[paidhre == 'No', wage := wkearn/hrs]
asec$hrly.earn <- log(asec$wage)
asec$annu.earn <- log(asec$wage * asec$hrs * asec$wkswork)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(annu.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "annual earnings", ylim = ylim, xlim = xlim)
abline(lm(b~a), col = 'gray')
text(min(a)+.05, max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
?signif
cbind(plyr::ddply(asec, ~sector, summarize,
`$\\bar{w}_u$`= round(mean(wkswork, na.rm = T),1),
`$\\sigma$`=round(sd(wkswork, na.rm = T),1))) %>%
knitr::kable(caption = "Weeks worked per year by industry.")
cbind(plyr::ddply(asec, ~sector, summarize,
`$\\bar{w}_u$`= round(mean(wkswork, na.rm = T),1),
`$\\sigma$`=round(sd(wkswork, na.rm = T),1)))[-21] %>%
knitr::kable(caption = "Weeks worked per year by industry.")
cbind(plyr::ddply(asec, ~sector, summarize,
`$\\bar{w}_u$`= round(mean(wkswork, na.rm = T),1),
`$\\sigma$`=round(sd(wkswork, na.rm = T),1)))[-21] %>%
knitr::kable(caption = "Weeks worked per year by industry.")
cbind(plyr::ddply(asec, ~sector, summarize,
`$\\bar{w}_u$`= round(mean(wkswork, na.rm = T),1),
`$\\sigma$`=round(sd(wkswork, na.rm = T),1)))[-21,] %>%
knitr::kable(caption = "Weeks worked per year by industry.")
length(sector.names)
length(2:20)
a <- lm(hrly.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
a <- a$coefficients[2:20]
b <- lm(annu.earn ~ sector + educ + exp^4 + sex + region + race + exp^4*educ, data = asec, weights = ernlwt*hrs)
b <- b$coefficients[2:20]
plot(a, b, xlab = "hourly earnings", ylab = "annual earnings", ylim = ylim, xlim = xlim, yaxt = "n")
abline(lm(b~a), col = 'gray')
text(min(a), max(b), round(1 - summary(lm(a ~ b))$r.squared,3))
secLabels(a,b)
sector.names
length(a)
length(b)
length(sector.names)
?switch
?xaxt
/par
?par
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
w = c(2,2,1)
v = c(1,2,2)
h = c(2,1,2)
ln(w~c+v)
lm(w~c+v)
lm(w~h+v)
w = c(2,2)
v = c(2,1)
h = c(1,2)
lm(w~h+v)
build
build <- commandArgs(TRUE)[1]
cat("Commencing", build, "R package installations.\n")
if (build == "RCC"){
## Set-up RCC Environment when "RCC" is specified as a command line argument
setwd('~')
unlink('R_libs/*', recursive = TRUE)
unlink('R-dev/*', recursive = TRUE)
}
source('~/Downloads/initialize_env.R', echo=TRUE)
source('~/Documents/2fpm/inputs/kerneling.R', echo=TRUE)
setwd('~/Documents/2fpm/inputs')
source('~/Documents/2fpm/inputs/kerneling.R', echo=TRUE)
source('~/Documents/2fpm/inputs/kerneling.R', echo=TRUE)
yr = 1999
cps.yr <- yr+1
asec.yr <- yr+1
message(paste(yr, 'from', cps.yr, 'data and', asec.yr, 'asec'))
asec.incomes <- data.frame(feather::read_feather(paste0('asec', asec.yr, 'sample.f')))
names(asec.incomes) <- c('hufaminc', 'ftotval', 'famtyp', 'asec.h_faminc', 'nppl', 'nkid',
'wsalval', 'sempval', 'farmval')
asec.incomes <- data.table(asec.incomes)
monthly.poverty.yr <- list(vector(length = 12), vector(length = 12))
for (mo in 1:12) {
index <- 12*(yr %% 1999) + mo
## get relevant CPS file for this month's poverty estimate
# offset lag structure for years
# yr2 <- 1999+((index+0)%/%12)
# offset lag structure for months (use "%% 12" since may cross years)
lagmo <- 0
yr2 <- cps.yr
mo2 <- (index + lagmo) %% 12
# with lagging, need the following ---
# if (mo2 < mo) {
#   mo2 <- mo2 + 1
#   yr2 <- cps.yr + 1
# }
#
# if(yr == 1999 & mo < 6) {
#   monthly.poverty.yr[[1]][mo] <- NA
#   monthly.poverty.yr[[2]][mo] <- NA
#   next   # needed for different lag structures
# }
# -------------------------------------
filename <- paste0('cps', substr(yr2,3,4), month.abb[mo2], '.rds')
cps <- data.table(readRDS(filename))
cps <- cps[hrhtype %in% 1:8, ]  # no group quarters
# !! -- this is the bulk of this project -- !!
# it is hard and necessary to have a good conversion between CPS and ASEC income categories
if (cps.yr %in% 2000:2001) {
cps[hufaminc %in% -2:-1, hufaminc := -1]
cps[hufaminc > 0, hufaminc := hufaminc - 1L]
} else if (cps.yr %in% 2002:2004) {
cps[hufaminc %in% -3:-1, hufaminc := 1]
cps[hufaminc > 0, hufaminc := hufaminc - 1L]
cps$hufaminc <- plyr::mapvalues(cps$hufaminc, 14:15, c(13,13), warn_missing = F)
} else if (cps.yr %in% 2005:2009) {
# nada
}
# the following data cleaning steps use the data.table syntax
cps[, h_seq := .GRP, by = hrhhid]  # repurpose variable h_seq into shorter ID
cps[prfamtyp == 3, ftype := 1L]    # move related subfamilies into primary family
cps[prfamtyp != 3, ftype := as.integer(prfamtyp)]
cps[ftype == 1, fid := 1]          # create family ID
cps[ftype != 1, fid := as.numeric(paste0(ftype, prfamnum))]
cps[is.na(fid), fid := -1]
cps[ftype == 5, fid := fid + 1:.N, by = .(h_seq)]
# count types of people in family
cps[, nkid := sum(peage < 18), by = .(h_seq, fid)]
cps[nkid > 8, nkid := 8]
cps[, nppl := .N + 2, by = .(h_seq, fid)]
cps[ftype %in% 1:3 & perrp %in% 1:2, hhage := peage, by = h_seq]              # identify reference person
cps[ftype %in% 1:3, hhage := as.integer(max(hhage, na.rm = T)), by = h_seq]   # give others that hhage
cps[ftype > 3, hhage := as.integer(max(peage)), by = .(h_seq, fid)]           # unrelated subfamilies get oldest in family
# adjust nppl accordingly
cps[hhage <  65 & nppl == 3, nppl := 1]
cps[hhage >= 65 & nppl == 3, nppl := 2]
cps[hhage <  65 & nppl == 4, nppl := 3]
cps[hhage >= 65 & nppl == 4, nppl := 4]
cps[nppl > 11, nppl := 11]
OPM <- matrix(off.thr(index - 12)$ouThresh, nrow = 11, byrow = T)  # turn threshold into matrix
cps[, threshold := OPM[cps$nkid*11 + cps$nppl]]
# classify family type
cps[prfamtyp %in% 1:3, primaryFam := 1]
cps[prfamtyp %in% 4:5, primaryFam := 0]
asec.incomes$primaryFam <- plyr::mapvalues(asec.incomes$famtyp, from = 1:5, to = c(1,1,1,0,0))
# restrict family sizes for income donation (safe since threshold already assigned)
# this could be optimized. right now it only cuts off nppl and nikds. alternatively:
# - after creating the group matrix, call diff()
# - the first row with diff()>1 gives the maximum family sizes using the original
#   grouping matrix
asec.incomes[nppl > 4, nppl := 4]
cps[nppl > 4, nppl := 4]
asec.incomes[nkid > 2, nkid := 2]
cps[nkid > 2, nkid := 2]
# assign the same groups to asec.incomes and cps
groups <- asec.incomes[, .(.GRP, .N), by = .(primaryFam, hufaminc, nppl, nkid)]
cps <- merge(cps, groups, by = c('primaryFam', 'hufaminc', 'nppl', 'nkid'), all.x = T)
groups <- merge(groups, cps[, .(Ncps = .N), by = GRP], by = 'GRP', all.x = T)
groups[is.na(Ncps), Ncps := 0]
asec.incomes[, N := .N, by = .(primaryFam, hufaminc, nppl, nkid)]
asec.incomes[, GRP := .GRP, by = .(primaryFam, hufaminc, nppl, nkid)]
# resample from asec.incomes to get means for CPS
cps <- cps[!is.na(GRP)]
setkey(cps, GRP)
setkey(asec.incomes, GRP)
means <- mapply(
function(x, m) {
# set.seed(32894+1)  # would need to change for-loop from being year-centered
x[sample(nrow(x), m, replace = T), .(ftotval, wsalval, sempval, farmval)]
},
x = split(asec.incomes, asec.incomes$GRP),
m = groups$Ncps) %>%
t %>%
unlist
# now get means of every category
means <- data.frame(split(means, sort(rep(1:4, nrow(cps)))))
names(means) <- c('inc', 'wsal', 'semp', 'farm')
cps$selfemp <- means$wsal + means$semp + means$farm      # alternative 1: add three self-employment sources
cps$selfemp <- pmax(means$wsal, means$semp, means$farm)  # alternative 2: (koji's choice) take max
cps$selfemp2 <- pmax(means$semp, means$farm)
cps$fincome <- rnorm(nrow(cps), means$inc, sd = 500)
cps$selfemp <- rnorm(cps$selfemp, sd = 500)
rm(means, groups)  # clean up
## you may want to merge in ASEC and use actual 'ftotval' to get family income when
## month is March but beware: CPS and ASEC do not use same sample of people so you
## may get wildly different estimates unless you can maybe account for change in weights
# if (mo == 3){
#   cps[, povstatus := as.numeric(ftotval < threshold)]
#   } else {
# I. basic: weekly earnings ~90% poverty
cps[, earnings := earn*50]  # annualize weekly earnings
# cps[pemlr %in% 3:7 & is.na(earn), earn := 0]  # unemployed and missing earnings -> set to zero. this does nothing
## choose between IIa|IIb|IIc
# IIa. add self employment if missing earnings
# cps[is.na(earn) & !is.na(selfemp), earnings := as.double(selfemp)]
# IIb. prefer self employment to earnings
# cps[!is.na(selfemp), earnings := as.double(selfemp)]
# IIc. add in only non-wage self-employment
cps[!is.na(earn) & !is.na(selfemp), earnings := earn*50 + selfemp2]
cps[ is.na(earn) & !is.na(selfemp), earnings := selfemp]
# earnings by family
cps[, earnings := sum(earnings, na.rm = T), by = .(h_seq, fid)]
# ----> poverty with earnings should be ~32%, drop to ~27% with self-employment earnings
cps[, povstatus := as.numeric(fincome < threshold)]
cps[, earnpov := as.numeric(earnings < threshold)]
monthly.poverty.yr[[1]][mo] <- weighted.mean(cps$povstatus, cps$weight.fn, na.rm = T)
monthly.poverty.yr[[2]][mo] <- weighted.mean(cps$earnpov, cps$weight.fn, na.rm = T)
}
mo
mo2
source('~/Documents/2fpm/inputs/kerneling.R', echo=TRUE)
yr
mo
yr = 2000
cps.yr <- yr+1
asec.yr <- yr+1
message(paste(yr, 'from', cps.yr, 'data and', asec.yr, 'asec'))
asec.incomes <- data.frame(feather::read_feather(paste0('asec', asec.yr, 'sample.f')))
names(asec.incomes) <- c('hufaminc', 'ftotval', 'famtyp', 'asec.h_faminc', 'nppl', 'nkid',
'wsalval', 'sempval', 'farmval')
asec.incomes <- data.table(asec.incomes)
monthly.poverty.yr <- list(vector(length = 12), vector(length = 12))
for (mo in 1:12) {
index <- 12*(yr %% 1999) + mo
## get relevant CPS file for this month's poverty estimate
# offset lag structure for years
# yr2 <- 1999+((index+0)%/%12)
# offset lag structure for months (use "%% 12" since may cross years)
lagmo <- 0
yr2 <- cps.yr
mo2 <- (index + lagmo) %% 13
# with lagging, need the following ---
# if (mo2 < mo) {
#   mo2 <- mo2 + 1
#   yr2 <- cps.yr + 1
# }
#
# if(yr == 1999 & mo < 6) {
#   monthly.poverty.yr[[1]][mo] <- NA
#   monthly.poverty.yr[[2]][mo] <- NA
#   next   # needed for different lag structures
# }
# -------------------------------------
filename <- paste0('cps', substr(yr2,3,4), month.abb[mo2], '.rds')
cps <- data.table(readRDS(filename))
cps <- cps[hrhtype %in% 1:8, ]  # no group quarters
# !! -- this is the bulk of this project -- !!
# it is hard and necessary to have a good conversion between CPS and ASEC income categories
if (cps.yr %in% 2000:2001) {
cps[hufaminc %in% -2:-1, hufaminc := -1]
cps[hufaminc > 0, hufaminc := hufaminc - 1L]
} else if (cps.yr %in% 2002:2004) {
cps[hufaminc %in% -3:-1, hufaminc := 1]
cps[hufaminc > 0, hufaminc := hufaminc - 1L]
cps$hufaminc <- plyr::mapvalues(cps$hufaminc, 14:15, c(13,13), warn_missing = F)
} else if (cps.yr %in% 2005:2009) {
# nada
}
# the following data cleaning steps use the data.table syntax
cps[, h_seq := .GRP, by = hrhhid]  # repurpose variable h_seq into shorter ID
cps[prfamtyp == 3, ftype := 1L]    # move related subfamilies into primary family
cps[prfamtyp != 3, ftype := as.integer(prfamtyp)]
cps[ftype == 1, fid := 1]          # create family ID
cps[ftype != 1, fid := as.numeric(paste0(ftype, prfamnum))]
cps[is.na(fid), fid := -1]
cps[ftype == 5, fid := fid + 1:.N, by = .(h_seq)]
# count types of people in family
cps[, nkid := sum(peage < 18), by = .(h_seq, fid)]
cps[nkid > 8, nkid := 8]
cps[, nppl := .N + 2, by = .(h_seq, fid)]
cps[ftype %in% 1:3 & perrp %in% 1:2, hhage := peage, by = h_seq]              # identify reference person
cps[ftype %in% 1:3, hhage := as.integer(max(hhage, na.rm = T)), by = h_seq]   # give others that hhage
cps[ftype > 3, hhage := as.integer(max(peage)), by = .(h_seq, fid)]           # unrelated subfamilies get oldest in family
# adjust nppl accordingly
cps[hhage <  65 & nppl == 3, nppl := 1]
cps[hhage >= 65 & nppl == 3, nppl := 2]
cps[hhage <  65 & nppl == 4, nppl := 3]
cps[hhage >= 65 & nppl == 4, nppl := 4]
cps[nppl > 11, nppl := 11]
OPM <- matrix(off.thr(index - 12)$ouThresh, nrow = 11, byrow = T)  # turn threshold into matrix
cps[, threshold := OPM[cps$nkid*11 + cps$nppl]]
# classify family type
cps[prfamtyp %in% 1:3, primaryFam := 1]
cps[prfamtyp %in% 4:5, primaryFam := 0]
asec.incomes$primaryFam <- plyr::mapvalues(asec.incomes$famtyp, from = 1:5, to = c(1,1,1,0,0))
# restrict family sizes for income donation (safe since threshold already assigned)
# this could be optimized. right now it only cuts off nppl and nikds. alternatively:
# - after creating the group matrix, call diff()
# - the first row with diff()>1 gives the maximum family sizes using the original
#   grouping matrix
asec.incomes[nppl > 4, nppl := 4]
cps[nppl > 4, nppl := 4]
asec.incomes[nkid > 2, nkid := 2]
cps[nkid > 2, nkid := 2]
# assign the same groups to asec.incomes and cps
groups <- asec.incomes[, .(.GRP, .N), by = .(primaryFam, hufaminc, nppl, nkid)]
cps <- merge(cps, groups, by = c('primaryFam', 'hufaminc', 'nppl', 'nkid'), all.x = T)
groups <- merge(groups, cps[, .(Ncps = .N), by = GRP], by = 'GRP', all.x = T)
groups[is.na(Ncps), Ncps := 0]
asec.incomes[, N := .N, by = .(primaryFam, hufaminc, nppl, nkid)]
asec.incomes[, GRP := .GRP, by = .(primaryFam, hufaminc, nppl, nkid)]
# resample from asec.incomes to get means for CPS
cps <- cps[!is.na(GRP)]
setkey(cps, GRP)
setkey(asec.incomes, GRP)
means <- mapply(
function(x, m) {
# set.seed(32894+1)  # would need to change for-loop from being year-centered
x[sample(nrow(x), m, replace = T), .(ftotval, wsalval, sempval, farmval)]
},
x = split(asec.incomes, asec.incomes$GRP),
m = groups$Ncps) %>%
t %>%
unlist
# now get means of every category
means <- data.frame(split(means, sort(rep(1:4, nrow(cps)))))
names(means) <- c('inc', 'wsal', 'semp', 'farm')
cps$selfemp <- means$wsal + means$semp + means$farm      # alternative 1: add three self-employment sources
cps$selfemp <- pmax(means$wsal, means$semp, means$farm)  # alternative 2: (koji's choice) take max
cps$selfemp2 <- pmax(means$semp, means$farm)
cps$fincome <- rnorm(nrow(cps), means$inc, sd = 500)
cps$selfemp <- rnorm(cps$selfemp, sd = 500)
rm(means, groups)  # clean up
## you may want to merge in ASEC and use actual 'ftotval' to get family income when
## month is March but beware: CPS and ASEC do not use same sample of people so you
## may get wildly different estimates unless you can maybe account for change in weights
# if (mo == 3){
#   cps[, povstatus := as.numeric(ftotval < threshold)]
#   } else {
# I. basic: weekly earnings ~90% poverty
cps[, earnings := earn*50]  # annualize weekly earnings
# cps[pemlr %in% 3:7 & is.na(earn), earn := 0]  # unemployed and missing earnings -> set to zero. this does nothing
## choose between IIa|IIb|IIc
# IIa. add self employment if missing earnings
# cps[is.na(earn) & !is.na(selfemp), earnings := as.double(selfemp)]
# IIb. prefer self employment to earnings
# cps[!is.na(selfemp), earnings := as.double(selfemp)]
# IIc. add in only non-wage self-employment
cps[!is.na(earn) & !is.na(selfemp), earnings := earn*50 + selfemp2]
cps[ is.na(earn) & !is.na(selfemp), earnings := selfemp]
# earnings by family
cps[, earnings := sum(earnings, na.rm = T), by = .(h_seq, fid)]
# ----> poverty with earnings should be ~32%, drop to ~27% with self-employment earnings
cps[, povstatus := as.numeric(fincome < threshold)]
cps[, earnpov := as.numeric(earnings < threshold)]
monthly.poverty.yr[[1]][mo] <- weighted.mean(cps$povstatus, cps$weight.fn, na.rm = T)
monthly.poverty.yr[[2]][mo] <- weighted.mean(cps$earnpov, cps$weight.fn, na.rm = T)
}
mpo
mo
yr
index <- 12*(yr %% 1999) + mo
lagmo <- 0
yr2 <- cps.yr
mo2 <- (index + lagmo) %% 13
yr2
mo2
,p
mo
index
source('~/Documents/2fpm/inputs/kerneling.R', echo=TRUE)
